<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PSeInt - Simulador de Pseudoc√≥digo</title>

    <!-- PWA Settings -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="IMA-Logo.png">
    <link rel="apple-touch-icon" href="IMA-Logo.png">
    <meta name="theme-color" content="#f0f0f0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="PSeInt App">

    <style>
        :root {
            --bg-gray: #f0f0f0;
            --border-color: #a0a0a0;
            --header-bg: #e1e1e1;
            --active-blue: #0066cc;
            --keyword-blue: #0000ff;
            --string-maroon: #800000;
            --comment-gray: #808080;
            --type-green: #008000;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, sans-serif;
        }

        body {
            background-color: var(--bg-gray);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-size: 13px;
        }

        /* Toolbar / Menu */
        .menu-bar {
            background-color: var(--header-bg);
            padding: 2px 10px;
            display: flex;
            gap: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .menu-item {
            cursor: pointer;
            padding: 2px 5px;
        }

        .menu-item:hover {
            background-color: #ccc;
        }

        .toolbar {
            background-color: var(--header-bg);
            padding: 5px 10px;
            display: flex;
            gap: 5px;
            border-bottom: 1px solid var(--border-color);
            align-items: center;
        }

        .tool-btn {
            border: 1px solid transparent;
            background: transparent;
            padding: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }

        .tool-btn:hover {
            border: 1px solid var(--border-color);
            background-color: #fff;
        }

        .tool-btn img, .tool-btn span {
            width: 20px;
            height: 20px;
            font-size: 18px;
        }

        .separator {
            width: 1px;
            height: 20px;
            background-color: var(--border-color);
            margin: 0 5px;
        }

        /* Main Layout */
        .main-layout {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Side Panels */
        .side-panel {
            width: 25px;
            background-color: var(--header-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 10px;
            cursor: pointer;
            z-index: 10;
        }

        .side-panel.right {
            border-right: none;
            border-left: 1px solid var(--border-color);
        }

        .vertical-text {
            writing-mode: vertical-lr;
            transform: rotate(180deg);
            white-space: nowrap;
            color: #444;
            font-weight: 500;
            margin-bottom: 30px;
        }

        .expanded-content {
            width: 220px;
            background-color: #fff;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .expanded-content.right {
            border-right: none;
            border-left: 1px solid var(--border-color);
        }

        .panel-header {
            background-color: var(--header-bg);
            padding: 5px 10px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }

        .close-btn {
            cursor: pointer;
            font-size: 16px;
        }

        /* Editor Area */
        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #fff;
            overflow: hidden;
            position: relative;
        }

        .tabs-bar {
            height: 25px;
            background-color: var(--header-bg);
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .tab {
            padding: 3px 15px;
            background-color: #ddd;
            border-right: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tab.active {
            background-color: #fff;
            border-bottom: 1px solid #fff;
            margin-bottom: -1px;
        }

        .editor-view {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        #lineNumbers {
            width: 40px;
            background-color: #f0f0f0;
            border-right: 1px solid #ddd;
            padding: 10px 5px;
            text-align: right;
            color: #999;
            font-family: 'Consolas', 'Courier New', monospace;
            line-height: 1.5;
            user-select: none;
        }

        .code-area {
            flex: 1;
            position: relative;
            overflow: auto;
        }

        #codeEditor, #syntaxHighlight {
            margin: 0;
            padding: 10px;
            width: 100%;
            height: 100%;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            tab-size: 4;
            white-space: pre;
            position: absolute;
            top: 0;
            left: 0;
            border: none;
            outline: none;
        }

        #codeEditor {
            background: transparent;
            color: transparent;
            caret-color: black;
            resize: none;
            z-index: 2;
        }

        #syntaxHighlight {
            background: white;
            color: black;
            z-index: 1;
            pointer-events: none;
        }

        /* Syntax Highlighting Classes */
        .sh-keyword { color: var(--keyword-blue); font-weight: bold; }
        .sh-string { color: var(--string-maroon); }
        .sh-comment { color: var(--comment-gray); font-style: italic; }
        .sh-type { color: var(--type-green); }
        .sh-identifier { color: black; }
        .sh-number { color: #f08000; }

        /* Commands Panel Content */
        .commands-list {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .command-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            border: 1px solid #ddd;
            background: #f9f9f9;
            cursor: pointer;
            text-align: left;
            border-radius: 4px;
        }

        .command-btn:hover {
            background: #eef;
            border-color: #aaf;
        }

        .command-icon {
            width: 32px;
            height: 20px;
            background: #eee;
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        /* Bottom Area */
        .bottom-area {
            height: 180px;
            display: flex;
            flex-direction: column;
            border-top: 1px solid var(--border-color);
            background-color: #fff;
        }

        .bottom-tabs {
            display: flex;
            background-color: var(--header-bg);
            border-bottom: 1px solid var(--border-color);
        }

        .bottom-tab {
            padding: 3px 15px;
            cursor: pointer;
            border-right: 1px solid var(--border-color);
        }

        .bottom-tab.active {
            background-color: #fff;
        }

        .bottom-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Consolas', 'Courier New', monospace;
        }

        .console-output {
            background-color: #000;
            color: #fff;
            padding: 10px;
            min-height: 100%;
            white-space: pre-wrap;
        }

        .console-line { margin-bottom: 2px; }
        .console-prompt { color: #0f0; }

        /* Helpers */
        .hidden { display: none !important; }

        /* Overlay for input */
        #inputOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .input-modal {
            background: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            width: 300px;
        }

        .input-modal input {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            border: 1px solid #ccc;
        }

        .input-modal .btns {
            margin-top: 15px;
            text-align: right;
        }

        .input-modal button {
            padding: 5px 15px;
            cursor: pointer;
        }

    </style>
</head>
<body>

    <nav class="menu-bar">
        <div class="menu-item">Archivo</div>
        <div class="menu-item">Editar</div>
        <div class="menu-item">Configurar</div>
        <div class="menu-item">Ejecutar</div>
        <div class="menu-item">Ayuda</div>
    </nav>

    <div class="toolbar">
        <button class="tool-btn" title="Nuevo" onclick="newProject()"><span>üìÑ</span></button>
        <button class="tool-btn" title="Abrir"><span>üìÇ</span></button>
        <button class="tool-btn" title="Guardar"><span>üíæ</span></button>
        <button class="tool-btn" title="Guardar como..."><span>üíæ+</span></button>
        <div class="separator"></div>
        <button class="tool-btn"><span>‚Ü©Ô∏è</span></button>
        <button class="tool-btn"><span>‚Ü™Ô∏è</span></button>
        <div class="separator"></div>
        <button class="tool-btn"><span>‚úÇÔ∏è</span></button>
        <button class="tool-btn"><span>üìã</span></button>
        <button class="tool-btn"><span>üì•</span></button>
        <div class="separator"></div>
        <button class="tool-btn" title="Ejecutar" onclick="runAlgorithm()"><span style="color: green;">‚ñ∂</span></button>
        <button class="tool-btn" title="Ejecutar paso a paso"><span>üë£</span></button>
        <button class="tool-btn" title="Dibujar diagrama de flujo"><span>üìä</span></button>
    </div>

    <div class="main-layout">
        <!-- Left Panels -->
        <div class="side-panel" id="leftPanelToggle" onclick="toggleLeftPanel()">
            <div class="vertical-text">lista de variables</div>
            <div class="vertical-text">operadores y funciones</div>
        </div>
        <div class="expanded-content hidden" id="leftPanel">
            <div class="panel-header">
                <span id="leftPanelTitle">Variables</span>
                <span class="close-btn" onclick="toggleLeftPanel()">√ó</span>
            </div>
            <div id="leftPanelBody" style="padding: 10px;">
                <div id="variableList">No hay variables definidas</div>
            </div>
        </div>

        <!-- Center Area (Editor) -->
        <div class="editor-container">
            <div class="tabs-bar">
                <div class="tab active">
                    <span id="tabTitle">sin_titulo</span>
                    <span style="font-size: 10px; margin-left: 5px;">√ó</span>
                </div>
            </div>
            <div class="editor-view">
                <div id="lineNumbers">1</div>
                <div class="code-area">
                    <div id="syntaxHighlight"></div>
                    <textarea id="codeEditor" spellcheck="false" oninput="updateEditor()" onscroll="syncScroll()">Algoritmo sin_titulo

FinAlgoritmo</textarea>
                </div>
            </div>
        </div>

        <!-- Right Panels -->
        <div class="expanded-content right" id="rightPanel">
            <div class="panel-header">
                <span>Comandos</span>
                <span class="close-btn" onclick="toggleRightPanel()">√ó</span>
            </div>
            <div class="commands-list">
                <button class="command-btn" onclick="insertCode('escribir')">
                    <div class="command-icon" style="color: blue;">'Hola !'</div>
                    <span>Escribir</span>
                </button>
                <button class="command-btn" onclick="insertCode('leer')">
                    <div class="command-icon" style="color: green;">Dato1</div>
                    <span>Leer</span>
                </button>
                <button class="command-btn" onclick="insertCode('asignar')">
                    <div class="command-icon">A&larr;B+i</div>
                    <span>Asignar</span>
                </button>
                <button class="command-btn" onclick="insertCode('si')">
                    <div class="command-icon" style="color: red;">Si...</div>
                    <span>Si-Entonces</span>
                </button>
                <button class="command-btn" onclick="insertCode('segun')">
                    <div class="command-icon">Segun</div>
                    <span>Segun</span>
                </button>
                <button class="command-btn" onclick="insertCode('mientras')">
                    <div class="command-icon">Mient...</div>
                    <span>Mientras</span>
                </button>
                <button class="command-btn" onclick="insertCode('repetir')">
                    <div class="command-icon">Repetir</div>
                    <span>Repetir</span>
                </button>
                <button class="command-btn" onclick="insertCode('para')">
                    <div class="command-icon">Para</div>
                    <span>Para</span>
                </button>
                <button class="command-btn" onclick="insertCode('funcion')">
                    <div class="command-icon">SubPr...</div>
                    <span>Funcion</span>
                </button>
            </div>
        </div>
        <div class="side-panel right" id="rightPanelToggle" onclick="toggleRightPanel()" style="display:none;">
            <div class="vertical-text">comandos</div>
            <div class="vertical-text">ejecuci√≥n paso a paso</div>
        </div>
    </div>

    <div class="bottom-area">
        <div class="bottom-tabs">
            <div class="bottom-tab active" onclick="showBottomTab('ayuda')">Ayuda R√°pida</div>
            <div class="bottom-tab" onclick="showBottomTab('consola')">Terminal / Salida</div>
        </div>
        <div class="bottom-content" id="bottomAyuda">
            <div id="quickHelp">
                Seleccione un comando para ver su descripci√≥n aqu√≠.
            </div>
        </div>
        <div class="bottom-content hidden" id="bottomConsola">
            <div class="console-output" id="consoleOutput">
                <div class="console-line">*** Ejecuci√≥n Iniciada. ***</div>
                <div class="console-line">*** Ejecuci√≥n Finalizada. ***</div>
            </div>
        </div>
    </div>

    <!-- Input Modal -->
    <div id="inputOverlay">
        <div class="input-modal">
            <div id="inputLabel">Ingrese un valor:</div>
            <input type="text" id="userInput" onkeypress="handleInputKeyPress(event)">
            <div class="btns">
                <button onclick="submitInput()">Aceptar</button>
            </div>
        </div>
    </div>

    <script>
        const editor = document.getElementById('codeEditor');
        const highlight = document.getElementById('syntaxHighlight');
        const lineNumbers = document.getElementById('lineNumbers');

        function toggleLeftPanel() {
            const panel = document.getElementById('leftPanel');
            const toggle = document.getElementById('leftPanelToggle');
            panel.classList.toggle('hidden');
            toggle.classList.toggle('hidden');
        }

        function toggleRightPanel() {
            const panel = document.getElementById('rightPanel');
            const toggle = document.getElementById('rightPanelToggle');
            panel.classList.toggle('hidden');
            toggle.classList.toggle('hidden');
        }

        function showBottomTab(tab) {
            document.querySelectorAll('.bottom-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.bottom-content').forEach(c => c.classList.add('hidden'));

            if (tab === 'ayuda') {
                document.querySelector('.bottom-tab:nth-child(1)').classList.add('active');
                document.getElementById('bottomAyuda').classList.remove('hidden');
            } else {
                document.querySelector('.bottom-tab:nth-child(2)').classList.add('active');
                document.getElementById('bottomConsola').classList.remove('hidden');
            }
        }

        function updateEditor() {
            const code = editor.value;
            applyHighlighting(code);
            updateLineNumbers(code);
            updateTabTitle(code);
        }

        function updateTabTitle(code) {
            const match = code.match(/(?:Algoritmo|Proceso)\s+([a-zA-Z0-9_]+)/i);
            if (match && match[1]) {
                document.getElementById('tabTitle').textContent = match[1];
            }
        }

        function updateLineNumbers(code) {
            const lines = code.split('\n').length;
            let nums = '';
            for (let i = 1; i <= lines; i++) {
                nums += i + '<br>';
            }
            lineNumbers.innerHTML = nums;
        }

        function syncScroll() {
            highlight.scrollTop = editor.scrollTop;
            highlight.scrollLeft = editor.scrollLeft;
            lineNumbers.scrollTop = editor.scrollTop;
        }

        function applyHighlighting(code) {
            const tokenizer = new Tokenizer(code);
            const tokens = tokenizer.tokenizeRaw(); // Need a raw tokenizer that keeps spaces

            let html = '';
            tokens.forEach(token => {
                const escaped = token.value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                switch(token.type) {
                    case 'KEYWORD': html += `<span class="sh-keyword">${escaped}</span>`; break;
                    case 'TYPE': html += `<span class="sh-type">${escaped}</span>`; break;
                    case 'STRING': html += `<span class="sh-string">${token.value.charAt(0)}${escaped.slice(1,-1)}${token.value.slice(-1)}</span>`; break;
                    case 'COMMENT': html += `<span class="sh-comment">${escaped}</span>`; break;
                    case 'NUMBER': html += `<span class="sh-number">${escaped}</span>`; break;
                    case 'WHITESPACE': html += escaped; break;
                    default: html += escaped;
                }
            });

            highlight.innerHTML = html + (code.endsWith('\n') ? ' ' : '');
        }

        function insertCode(type) {
            let snippet = '';
            let help = '';
            switch(type) {
                case 'escribir':
                    snippet = 'Escribir "mensaje";';
                    help = 'La instrucci√≥n <b>Escribir</b> permite mostrar valores al ambiente (pantalla).';
                    break;
                case 'leer':
                    snippet = 'Leer variable;';
                    help = 'La instrucci√≥n <b>Leer</b> permite ingresar informaci√≥n desde el ambiente (teclado).';
                    break;
                case 'asignar':
                    snippet = 'variable <- expresion;';
                    help = 'La instrucci√≥n de <b>Asignaci√≥n</b> permite almacenar un valor en una variable.';
                    break;
                case 'si':
                    snippet = 'Si condicion Entonces\n\t\nSino\n\t\nFinSi';
                    help = 'La instrucci√≥n <b>Si-Entonces</b> ejecuta una secuencia de instrucciones seg√∫n una condici√≥n l√≥gica.';
                    break;
                case 'mientras':
                    snippet = 'Mientras condicion Hacer\n\t\nFinMientras';
                    help = 'La instrucci√≥n <b>Mientras</b> ejecuta un bloque de instrucciones mientras una condici√≥n sea verdadera.';
                    break;
                case 'para':
                    snippet = 'Para variable <- valor_inicial Hasta valor_final Con Paso paso Hacer\n\t\nFinPara';
                    help = 'La instrucci√≥n <b>Para</b> ejecuta una secuencia de instrucciones un n√∫mero determinado de veces.';
                    break;
                // Add more cases as needed
            }

            if (snippet) {
                const start = editor.selectionStart;
                const end = editor.selectionEnd;
                const text = editor.value;
                editor.value = text.substring(0, start) + snippet + text.substring(end);
                editor.selectionStart = editor.selectionEnd = start + snippet.indexOf('\n') > -1 ? start + snippet.indexOf('\n') + 2 : start + snippet.length;
                editor.focus();
                updateEditor();
            }

            if (help) {
                document.getElementById('quickHelp').innerHTML = help;
            }
        }

        function newProject() {
            editor.value = "Algoritmo sin_titulo\n\nFinAlgoritmo";
            updateEditor();
            clearConsole();
        }

        function clearConsole() {
            document.getElementById('consoleOutput').innerHTML = '';
        }

        function printToConsole(text, isPrompt = false) {
            const div = document.createElement('div');
            div.className = 'console-line' + (isPrompt ? ' console-prompt' : '');
            div.textContent = (isPrompt ? '> ' : '') + text;
            document.getElementById('consoleOutput').appendChild(div);
            document.getElementById('bottomConsola').scrollTop = document.getElementById('bottomConsola').scrollHeight;
        }

        // Interpreter Implementation
        class Tokenizer {
            constructor(code) {
                this.code = code;
                this.pos = 0;
                this.tokens = [];
                this.keywords = new Set([
                    'algoritmo', 'finalgoritmo', 'proceso', 'finproceso',
                    'definir', 'como', 'leer', 'escribir',
                    'si', 'entonces', 'sino', 'finsi',
                    'mientras', 'hacer', 'finmientras',
                    'para', 'hasta', 'con', 'paso', 'finpara'
                ]);
                this.types = new Set(['entero', 'real', 'logico', 'caracter', 'texto', 'cadena']);
            }

            tokenizeRaw() {
                const tokens = [];
                while (this.pos < this.code.length) {
                    let char = this.code[this.pos];

                    if (/\s/.test(char)) {
                        let ws = '';
                        while (this.pos < this.code.length && /\s/.test(this.code[this.pos])) {
                            ws += this.code[this.pos++];
                        }
                        tokens.push({ type: 'WHITESPACE', value: ws });
                        continue;
                    }

                    if (char === '/' && this.code[this.pos + 1] === '/') {
                        let comment = '';
                        while (this.pos < this.code.length && this.code[this.pos] !== '\n') {
                            comment += this.code[this.pos++];
                        }
                        tokens.push({ type: 'COMMENT', value: comment });
                        continue;
                    }

                    if (/[a-zA-Z_]/.test(char)) {
                        let id = '';
                        while (this.pos < this.code.length && /[a-zA-Z0-9_]/.test(this.code[this.pos])) {
                            id += this.code[this.pos++];
                        }
                        const lowerId = id.toLowerCase();
                        if (this.keywords.has(lowerId)) {
                            tokens.push({ type: 'KEYWORD', value: id });
                        } else if (this.types.has(lowerId)) {
                            tokens.push({ type: 'TYPE', value: id });
                        } else {
                            tokens.push({ type: 'IDENTIFIER', value: id });
                        }
                        continue;
                    }

                    if (/[0-9]/.test(char)) {
                        let num = '';
                        while (this.pos < this.code.length && /[0-9.]/.test(this.code[this.pos])) {
                            num += this.code[this.pos++];
                        }
                        tokens.push({ type: 'NUMBER', value: num });
                        continue;
                    }

                    if (char === '"' || char === "'") {
                        let quote = char;
                        let str = quote;
                        this.pos++;
                        while (this.pos < this.code.length && this.code[this.pos] !== quote) {
                            str += this.code[this.pos++];
                        }
                        if (this.pos < this.code.length) str += this.code[this.pos++];
                        tokens.push({ type: 'STRING', value: str });
                        continue;
                    }

                    if (char === '<' && this.code[this.pos + 1] === '-') {
                        tokens.push({ type: 'OPERATOR', value: '<-' });
                        this.pos += 2;
                        continue;
                    }

                    if (/[+\-*/%^=<>!]/.test(char)) {
                        let op = char;
                        if ((char === '<' || char === '>' || char === '!') && this.code[this.pos + 1] === '=') {
                            op += this.code[++this.pos];
                        }
                        tokens.push({ type: 'OPERATOR', value: op });
                        this.pos++;
                        continue;
                    }

                    tokens.push({ type: 'OTHER', value: this.code[this.pos++] });
                }
                this.pos = 0; // Reset for potential next use
                return tokens;
            }

            tokenize() {
                while (this.pos < this.code.length) {
                    let char = this.code[this.pos];

                    if (/\s/.test(char)) {
                        this.pos++;
                        continue;
                    }

                    if (char === '/' && this.code[this.pos + 1] === '/') {
                        while (this.pos < this.code.length && this.code[this.pos] !== '\n') this.pos++;
                        continue;
                    }

                    if (/[a-zA-Z_]/.test(char)) {
                        let id = '';
                        while (this.pos < this.code.length && /[a-zA-Z0-9_]/.test(this.code[this.pos])) {
                            id += this.code[this.pos++];
                        }
                        if (this.keywords.has(id.toLowerCase())) {
                            this.tokens.push({ type: 'KEYWORD', value: id.toLowerCase() });
                        } else {
                            this.tokens.push({ type: 'IDENTIFIER', value: id });
                        }
                        continue;
                    }

                    if (/[0-9]/.test(char)) {
                        let num = '';
                        while (this.pos < this.code.length && /[0-9.]/.test(this.code[this.pos])) {
                            num += this.code[this.pos++];
                        }
                        this.tokens.push({ type: 'NUMBER', value: parseFloat(num) });
                        continue;
                    }

                    if (char === '"' || char === "'") {
                        let quote = char;
                        let str = '';
                        this.pos++;
                        while (this.pos < this.code.length && this.code[this.pos] !== quote) {
                            str += this.code[this.pos++];
                        }
                        this.pos++;
                        this.tokens.push({ type: 'STRING', value: str });
                        continue;
                    }

                    if (char === '<' && this.code[this.pos + 1] === '-') {
                        this.tokens.push({ type: 'OPERATOR', value: '<-' });
                        this.pos += 2;
                        continue;
                    }

                    if (/[+\-*/%^=<>!]/.test(char)) {
                        let op = char;
                        if ((char === '<' || char === '>' || char === '!') && this.code[this.pos + 1] === '=') {
                            op += this.code[++this.pos];
                        }
                        this.tokens.push({ type: 'OPERATOR', value: op });
                        this.pos++;
                        continue;
                    }

                    if (/[(),;[\]]/.test(char)) {
                        this.tokens.push({ type: 'PUNCTUATION', value: char });
                        this.pos++;
                        continue;
                    }

                    this.pos++; // Skip unknown
                }
                return this.tokens;
            }
        }

        class Parser {
            constructor(tokens) {
                this.tokens = tokens;
                this.pos = 0;
            }

            peek() { return this.tokens[this.pos]; }
            consume() { return this.tokens[this.pos++]; }
            match(type, value) {
                const token = this.peek();
                if (token && token.type === type && (!value || token.value === value)) {
                    return this.consume();
                }
                return null;
            }

            parse() {
                const program = [];
                while (this.pos < this.tokens.length) {
                    const stmt = this.parseStatement();
                    if (stmt) program.push(stmt);
                    else this.pos++;
                }
                return program;
            }

            parseStatement() {
                const token = this.peek();
                if (!token) return null;

                if (token.type === 'KEYWORD') {
                    switch (token.value) {
                        case 'algoritmo':
                        case 'proceso':
                            this.consume();
                            const name = this.consume().value;
                            return { type: 'PROCESO_START', name };
                        case 'finalgoritmo':
                        case 'finproceso':
                            this.consume();
                            return { type: 'PROCESO_END' };
                        case 'definir':
                            return this.parseDefinir();
                        case 'escribir':
                            return this.parseEscribir();
                        case 'leer':
                            return this.parseLeer();
                        case 'si':
                            return this.parseSi();
                        case 'mientras':
                            return this.parseMientras();
                        case 'para':
                            return this.parsePara();
                        case 'repetir':
                            return this.parseRepetir();
                        case 'segun':
                            return this.parseSegun();
                    }
                }

                if (token.type === 'IDENTIFIER') {
                    return this.parseAssignment();
                }

                return null;
            }

            parseDefinir() {
                this.consume(); // definir
                const vars = [];
                vars.push(this.consume().value);
                while (this.match('PUNCTUATION', ',')) {
                    vars.push(this.consume().value);
                }
                this.match('KEYWORD', 'como');
                const dataType = this.consume().value;
                this.match('PUNCTUATION', ';');
                return { type: 'DEFINIR', variables: vars, dataType };
            }

            parseEscribir() {
                this.consume(); // escribir
                const expressions = [];
                expressions.push(this.parseExpression());
                while (this.match('PUNCTUATION', ',')) {
                    expressions.push(this.parseExpression());
                }
                this.match('PUNCTUATION', ';');
                return { type: 'ESCRIBIR', expressions };
            }

            parseLeer() {
                this.consume(); // leer
                const vars = [];
                vars.push(this.consume().value);
                while (this.match('PUNCTUATION', ',')) {
                    vars.push(this.consume().value);
                }
                this.match('PUNCTUATION', ';');
                return { type: 'LEER', variables: vars };
            }

            parseSi() {
                this.consume(); // si
                const condition = this.parseExpression();
                this.match('KEYWORD', 'entonces');
                const thenBranch = [];
                while (this.peek() && !(this.peek().type === 'KEYWORD' && (this.peek().value === 'sino' || this.peek().value === 'finsi'))) {
                    thenBranch.push(this.parseStatement());
                }
                let elseBranch = [];
                if (this.match('KEYWORD', 'sino')) {
                    while (this.peek() && !(this.peek().type === 'KEYWORD' && this.peek().value === 'finsi')) {
                        elseBranch.push(this.parseStatement());
                    }
                }
                this.match('KEYWORD', 'finsi');
                return { type: 'SI', condition, thenBranch, elseBranch };
            }

            parseMientras() {
                this.consume(); // mientras
                const condition = this.parseExpression();
                this.match('KEYWORD', 'hacer');
                const body = [];
                while (this.peek() && !(this.peek().type === 'KEYWORD' && this.peek().value === 'finmientras')) {
                    const stmt = this.parseStatement();
                    if (stmt) body.push(stmt); else this.pos++;
                }
                this.match('KEYWORD', 'finmientras');
                this.match('PUNCTUATION', ';');
                return { type: 'MIENTRAS', condition, body };
            }

            parsePara() {
                this.consume(); // para
                const variable = this.consume().value;
                this.match('OPERATOR', '<-');
                const startExpr = this.parseExpression();
                this.match('KEYWORD', 'hasta');
                const endExpr = this.parseExpression();
                let stepExpr = { type: 'LITERAL', valueType: 'NUMBER', value: 1 };
                if (this.match('KEYWORD', 'con')) {
                    this.match('KEYWORD', 'paso');
                    stepExpr = this.parseExpression();
                }
                this.match('KEYWORD', 'hacer');
                const body = [];
                while (this.peek() && !(this.peek().type === 'KEYWORD' && this.peek().value === 'finpara')) {
                    const stmt = this.parseStatement();
                    if (stmt) body.push(stmt); else this.pos++;
                }
                this.match('KEYWORD', 'finpara');
                this.match('PUNCTUATION', ';');
                return { type: 'PARA', variable, startExpr, endExpr, stepExpr, body };
            }

            parseRepetir() {
                this.consume(); // repetir
                const body = [];
                while (this.peek() && !(this.peek().type === 'KEYWORD' && this.peek().value === 'hasta')) {
                    const stmt = this.parseStatement();
                    if (stmt) body.push(stmt); else this.pos++;
                }
                this.match('KEYWORD', 'hasta');
                this.match('KEYWORD', 'que');
                const condition = this.parseExpression();
                this.match('PUNCTUATION', ';');
                return { type: 'REPETIR', body, condition };
            }

            parseSegun() {
                this.consume(); // segun
                const variable = this.consume().value;
                this.match('KEYWORD', 'hacer');
                const cases = [];
                let otherwise = [];
                while (this.peek() && !(this.peek().type === 'KEYWORD' && this.peek().value === 'finsegun')) {
                    if (this.match('KEYWORD', 'de')) {
                        this.match('KEYWORD', 'otro');
                        this.match('KEYWORD', 'modo');
                        this.match('PUNCTUATION', ':');
                        while (this.peek() && !(this.peek().type === 'KEYWORD' && this.peek().value === 'finsegun')) {
                            const stmt = this.parseStatement();
                            if (stmt) otherwise.push(stmt); else this.pos++;
                        }
                    } else {
                        const values = [];
                        values.push(this.parseExpression());
                        while (this.match('PUNCTUATION', ',')) {
                            values.push(this.parseExpression());
                        }
                        this.match('PUNCTUATION', ':');
                        const body = [];
                        // Collect statements until next case or De Otro Modo or FinSegun
                        while (this.peek() && !(this.peek().type === 'KEYWORD' && (this.peek().value === 'de' || this.peek().value === 'finsegun')) && this.peek().type !== 'NUMBER' && this.peek().type !== 'STRING') {
                             const stmt = this.parseStatement();
                             if (stmt) body.push(stmt); else this.pos++;
                        }
                        cases.push({ values, body });
                    }
                }
                this.match('KEYWORD', 'finsegun');
                this.match('PUNCTUATION', ';');
                return { type: 'SEGUN', variable, cases, otherwise };
            }

            parseAssignment() {
                const variable = this.consume().value;
                if (!this.match('OPERATOR', '<-') && !this.match('OPERATOR', '=')) return null;
                const expr = this.parseExpression();
                this.match('PUNCTUATION', ';');
                return { type: 'ASSIGN', variable, expression: expr };
            }

            parseExpression() {
                let left = this.parsePrimary();
                while (this.peek() && this.peek().type === 'OPERATOR') {
                    const op = this.consume().value;
                    const right = this.parsePrimary();
                    left = { type: 'BINARY_OP', left, op, right };
                }
                return left;
            }

            parsePrimary() {
                const token = this.consume();
                if (token.type === 'NUMBER' || token.type === 'STRING' || token.type === 'IDENTIFIER') {
                    return { type: 'LITERAL', valueType: token.type, value: token.value };
                }
                return null;
            }
        }

        class Interpreter {
            constructor(printFn, inputFn, updateVarsFn) {
                this.variables = {};
                this.print = printFn;
                this.input = inputFn;
                this.updateVars = updateVarsFn;
                this.isWaitingForInput = false;
                this.inputVar = null;
                this.program = [];
                this.pc = 0;
            }

            async execute(program) {
                this.program = program;
                this.pc = 0;
                while (this.pc < this.program.length) {
                    if (this.isWaitingForInput) return;
                    await this.step();
                }
            }

            async step() {
                const stmt = this.program[this.pc];
                console.log('Executing:', stmt);
                switch (stmt.type) {
                    case 'DEFINIR':
                        stmt.variables.forEach(v => {
                            this.variables[v] = { type: stmt.dataType, value: null };
                        });
                        break;
                    case 'ASSIGN':
                        this.variables[stmt.variable].value = this.evaluate(stmt.expression);
                        break;
                    case 'ESCRIBIR':
                        const out = stmt.expressions.map(e => this.evaluate(e)).join('');
                        this.print(out);
                        break;
                    case 'LEER':
                        for (const v of stmt.variables) {
                            const val = await this.input(`Ingrese valor para ${v}:`);
                            this.variables[v].value = this.castValue(val, this.variables[v].type);
                        }
                        break;
                    case 'SI':
                        if (this.evaluate(stmt.condition)) {
                            await this.executeBlock(stmt.thenBranch);
                        } else {
                            await this.executeBlock(stmt.elseBranch);
                        }
                        break;
                    case 'MIENTRAS':
                        while (this.evaluate(stmt.condition)) {
                            await this.executeBlock(stmt.body);
                        }
                        break;
                    case 'PARA':
                        const start = this.evaluate(stmt.startExpr);
                        const end = this.evaluate(stmt.endExpr);
                        const stepValue = this.evaluate(stmt.stepExpr);
                        this.variables[stmt.variable].value = start;
                        while ((stepValue >= 0 && this.variables[stmt.variable].value <= end) || (stepValue < 0 && this.variables[stmt.variable].value >= end)) {
                            await this.executeBlock(stmt.body);
                            this.variables[stmt.variable].value += stepValue;
                            this.updateVars(this.variables);
                        }
                        break;
                    case 'REPETIR':
                        do {
                            await this.executeBlock(stmt.body);
                        } while (!this.evaluate(stmt.condition));
                        break;
                    case 'SEGUN':
                        const val = this.variables[stmt.variable].value;
                        let matched = false;
                        for (const c of stmt.cases) {
                            if (c.values.some(v => this.evaluate(v) === val)) {
                                await this.executeBlock(c.body);
                                matched = true;
                                break;
                            }
                        }
                        if (!matched && stmt.otherwise.length > 0) {
                            await this.executeBlock(stmt.otherwise);
                        }
                        break;
                }
                this.pc++;
                this.updateVars(this.variables);
            }

            async executeBlock(block) {
                const oldProgram = this.program;
                const oldPc = this.pc;
                this.program = block;
                this.pc = 0;
                while (this.pc < this.program.length) {
                    await this.step();
                }
                this.program = oldProgram;
                this.pc = oldPc;
            }

            evaluate(expr) {
                if (expr.type === 'LITERAL') {
                    if (expr.valueType === 'IDENTIFIER') {
                        if (this.variables[expr.value]) return this.variables[expr.value].value;
                        throw new Error(`Variable no definida: ${expr.value}`);
                    }
                    return expr.value;
                }
                if (expr.type === 'BINARY_OP') {
                    const left = this.evaluate(expr.left);
                    const right = this.evaluate(expr.right);
                    switch (expr.op) {
                        case '+': return left + right;
                        case '-': return left - right;
                        case '*': return left * right;
                        case '/': return left / right;
                        case '=': return left === right;
                        case '<': return left < right;
                        case '>': return left > right;
                        case '<=': return left <= right;
                        case '>=': return left >= right;
                        case '!=':
                        case '<>': return left !== right;
                    }
                }
            }

            castValue(val, type) {
                switch (type.toLowerCase()) {
                    case 'entero': return parseInt(val);
                    case 'real': return parseFloat(val);
                    case 'logico': return val.toLowerCase() === 'verdadero';
                    default: return val;
                }
            }
        }

        let interpreter;
        let inputResolver;

        function runAlgorithm() {
            showBottomTab('consola');
            clearConsole();
            printToConsole('*** Ejecuci√≥n Iniciada. ***');

            const code = editor.value;
            const tokenizer = new Tokenizer(code);
            const tokens = tokenizer.tokenize();
            const parser = new Parser(tokens);
            const program = parser.parse();

            console.log('Program:', program);

            interpreter = new Interpreter(
                (text) => printToConsole(text),
                async (promptText) => {
                    document.getElementById('inputLabel').textContent = promptText;
                    document.getElementById('inputOverlay').style.display = 'flex';
                    document.getElementById('userInput').focus();
                    return new Promise(resolve => {
                        inputResolver = resolve;
                    });
                },
                (vars) => {
                    const list = document.getElementById('variableList');
                    list.innerHTML = '';
                    for (const [name, data] of Object.entries(vars)) {
                        const div = document.createElement('div');
                        div.style.marginBottom = '5px';
                        div.innerHTML = `<b>${name}</b>: ${data.type} = ${data.value}`;
                        list.appendChild(div);
                    }
                }
            );

            interpreter.execute(program).then(() => {
                printToConsole('*** Ejecuci√≥n Finalizada. ***');
            }).catch(e => {
                printToConsole('ERROR: ' + e.message);
            });
        }

        function submitInput() {
            const val = document.getElementById('userInput').value;
            document.getElementById('inputOverlay').style.display = 'none';
            document.getElementById('userInput').value = '';
            if (inputResolver) {
                inputResolver(val);
                inputResolver = null;
            }
        }

        function handleInputKeyPress(e) {
            if (e.key === 'Enter') {
                submitInput();
            }
        }

        // Initialize
        updateEditor();

        // PWA update logic
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js?v=10')
                    .then(reg => {
                        reg.onupdatefound = () => {
                            const installingWorker = reg.installing;
                            installingWorker.onstatechange = () => {
                                if (installingWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    if(confirm("Nueva versi√≥n disponible. ¬øDeseas actualizar ahora?")) {
                                        window.location.reload();
                                    }
                                }
                            };
                        };
                    })
                    .catch(err => console.log('SW error', err));
            });
        }
    </script>
</body>
</html>
